class BardisModel:
    """
    BardisModel class encapsulates the computation of flows and derivatives for a given state and parameters in a socio-economic model.
    Methods:
        compute_flows(state, parameters):
        compute_derivatives(state, flows):
        run_bardis_model(state, time, parameters):
    """
    
    def compute_flows(self, state, parameters):
        """
        Compute the flows for the given state and parameters.
        Parameters:
        state (tuple): A tuple containing the state variables (Resources, Economy, Bureaucracy, Pollution).
        parameters (dict): A dictionary containing the parameters for the model:
            - k_resources (float): Coefficient for resource inflow.
            - k_pollution (float): Coefficient for extractive pollution.
            - ef_economy_resources_on_prod (float): Efficiency factor of economy and resources on production.
            - ef_bureaucracy_on_prod (float): Efficiency factor of bureaucracy on production.
            - k_deprec (float): Coefficient for depreciation.
            - ef_pollution_on_depreciation (float): Efficiency factor of pollution on depreciation.
            - ef_economy_on_bureaucracy (float): Efficiency factor of economy on bureaucracy creation.
            - k_bureaucracy (float): Coefficient for bureaucracy creation.
            - k_decay_bureaucracy (float): Coefficient for bureaucracy decay.
            - ef_pollution_on_bureaucracy (float): Efficiency factor of pollution on bureaucracy decay.
            - k_pollution_decay (float): Coefficient for pollution abatement.
        Returns:
        dict: A dictionary containing the computed flows:
            - "resource_inflow" (float): The inflow of resources.
            - "extractive_pollution" (float): The pollution generated by extraction.
            - "production" (float): The production value.
            - "depreciation" (float): The depreciation value.
            - "bureaucracy_creation" (float): The creation of bureaucracy.
            - "bureaucracy_decay" (float): The decay of bureaucracy.
            - "pollution_abatement" (float): The abatement of pollution.
        """
        
        # Unpack parameters
        k_resources = parameters["k_resources"]
        k_pollution = parameters["k_pollution"]
        ef_economy_resources_on_prod = parameters["ef_economy_resources_on_prod"]
        ef_bureaucracy_on_prod = parameters["ef_bureaucracy_on_prod"]
        k_deprec = parameters["k_deprec"]
        ef_pollution_on_depreciation = parameters["ef_pollution_on_depreciation"]
        ef_economy_on_bureaucracy = parameters["ef_economy_on_bureaucracy"]
        k_bureaucracy = parameters["k_bureaucracy"]
        k_decay_bureaucracy = parameters["k_decay_bureaucracy"]
        ef_pollution_on_bureaucracy = parameters["ef_pollution_on_bureaucracy"]
        k_pollution_decay = parameters["k_pollution_decay"]
        
        # Unpack state variables
        Resources, Economy, Bureaucracy, Pollution = state

        # Compute flows
        resource_inflow = k_resources * Resources
        extractive_pollution = k_pollution * Economy * Resources

        production = ef_economy_resources_on_prod * Resources * Economy * Bureaucracy
        depreciation = k_deprec * Economy * Pollution

        bureaucracy_creation = ef_economy_on_bureaucracy * Economy * Bureaucracy
        bureaucracy_decay = k_decay_bureaucracy * Bureaucracy * Pollution

        pollution_abatement = k_pollution_decay * Pollution

        # Store results in a dictionary
        flows = {
            "resource_inflow": resource_inflow,
            "extractive_pollution": extractive_pollution,
            "production": production,
            "depreciation": depreciation,
            "bureaucracy_creation": bureaucracy_creation,
            "bureaucracy_decay": bureaucracy_decay,
            "pollution_abatement": pollution_abatement
        }

        return flows

    def compute_derivatives(self, state, flows):
        """
        Compute the derivatives of the state variables based on the given flows.

        Parameters:
        state (list): A list containing the current values of the state variables [Resources, Economy, Bureaucracy, Pollution].
        flows (dict): A dictionary containing the flow values with keys:
            - "resource_inflow": The inflow of resources.
            - "extractive_pollution": The pollution generated from resource extraction.
            - "production": The production rate.
            - "depreciation": The depreciation rate of the economy.
            - "bureaucracy_creation": The rate of bureaucracy creation.
            - "bureaucracy_decay": The rate of bureaucracy decay.
            - "pollution_abatement": The rate of pollution abatement.

        Returns:
        list: A list containing the derivatives [dResources, dEconomy, dBureaucracy, dPollution] of the state variables.
        """

        # Unpack flows
        resource_inflow = flows["resource_inflow"]
        extractive_pollution = flows["extractive_pollution"]
        production = flows["production"]
        depreciation = flows["depreciation"]
        bureaucracy_creation = flows["bureaucracy_creation"]
        bureaucracy_decay = flows["bureaucracy_decay"]
        pollution_abatement = flows["pollution_abatement"]

        # Unpack state variables
        Resources, Economy, Bureaucracy, Pollution = state

        # Compute derivatives with conditional checks
        dResources = resource_inflow - production - extractive_pollution if Resources > 0 else 0
        dEconomy = production - depreciation - bureaucracy_creation if Economy > 0 else 0
        dBureaucracy = bureaucracy_creation - bureaucracy_decay if Bureaucracy > 0 else 0
        dPollution = depreciation + bureaucracy_decay + extractive_pollution - pollution_abatement if Pollution > 0 else 0

        return [dResources, dEconomy, dBureaucracy, dPollution]

    def run_bardis_model(self, state, time,  parameters):
        """
        Run the Bardis model to compute the derivatives based on the given state, time, and parameters.

        Args:
            state (dict): The current state of the system.
            time (float): The current time.
            parameters (dict): The parameters required for the model.

        Returns:
            dict: The computed derivatives of the state variables.
        """

        # Compute flows
        flows = self.compute_flows(state, parameters)

        # Compute derivatives
        derivatives = self.compute_derivatives(state, flows)

        return derivatives
